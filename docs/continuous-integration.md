# 版本管理及持续集成设计

## 工具选型

### 版本管理工具

系统采用微服务架构，通过`gitlab`对版本进行管理。整个系统是一个独立的版本仓库。每一个组件是一个单独的文件夹。每一个组件都可以独立编译。版本仓库仅有1个长期分支：主线分支`master`。

### 持续集成工具

持续集成过程由`Jenkins`进行管理。持续集成工具负责监控代码提交，对提交的代码进行编译、构建、测试、打包，最终产生一个docker image，并上传至内部的docker仓库。

持续集成工具负责代码从提交到发布的整个过程。是整个开发流程的核心。

### docker registry

系统的最终发布物为一系列docker images。系统使用的**所有的**docker images（包括基础设施的image）都由公司内部的docker registry进行管理。docker image的tag将被用于发布版本管理。

### 部署工具

部署工具负责选择适当的发布版本，将其部署至客户服务器。同时记录每一次部署行为。部署工具及部署方法待定。

## 系统开发流程设计

### 开发过程

为了避免分支污染及有效控制代码质量，各开发人员均fork一份代码库自行管理。每一个新功能或修改创建一个分支。待开发完成后，向主版本提交`Merge Request`。代码审核人员对每一个`Merge Request`进行审核，审核通过可以进入主线分支。审核未通过的可以进一步修改，直至通过。如果某个Request是不必要的，也可以暂缓合并或者直接撤回。开发人员提交`Merge Request`时，必须关联对应的`issue id`。一个`Merge Request`解决一个issue。一旦合并进入主线，持续集成工具将自动集成此次提交。如果集成失败则需要开发人员进行修改，直至集成成功。集成成功后，原分支将被关闭或删除。避免污染时间线。

所有的开发都必须从建立`issue`开始。issue的建立人可以是需求、测试、开发者或各类流程管理工具（自动化创建issue）。issue的内容可以是需求、bug或改进。issue由issue管理工具进行管理，这里不再赘述。issue管理工具必须能与gitlab及持续集成工具整合。简单起见，初期可以直接使用gitlab自带的issue管理功能。

另外要注意的一点是，由于引入了每日构建，每日的提交必须完整。不允许将不完整的功能提交至主线。不完整的提交可以暂存在私有仓库或分支中，待开发完成一并提交Merge Request。在提交Merge Request之前，可以考虑使用git的`rebase`功能对提交进行整理。

### 持续集成过程

目前定义了四种不同的持续集成过程。下面分别详述。

#### 提交编译过程

当版本仓库主线有新的提交时，将触发提交编译过程。过程如下：

1. 设置版本号为字符串“C`BUILD_NUMBER`”
2. 构建名设置为当前版本号。
3. 从版本仓库主线分支checkout完整的代码。然后判断组件子目录中哪些组件发生了变化，变化的组件将会被编译。
4. 将提交日志作为构建时的changelog。
5. 将版本号写入特定的Java代码，该信息将在运行时写入运行日志。如果在上一步发现有多个组件需要编译，对于该次构建，这些组件的`BUILD_NUMBER`是相同的
6. 编译每一个需要构建的组件。不同组件间的编译可以是并发的。
7. 编译完成后，对每一个组件进行单元测试。不同组件间的测试可以是并发的。
8. 检查编译结果、单元测试结果和单元测试覆盖率。有任一项没有达到要求，则此次构建失败。
9. 如果构建成功，则将构建结果打包成docker image。其tag为版本号
10. 将打包好的docker image上传至docker registry。
11. 如果构建失败，将构建结果通知相关开发人员。

提交编译过程主要是通过编译、单元测试及测试覆盖率来确保每次提交的正确性。另外，其构建结果也可以在特殊情况下作为测试的备选结果使用。

#### 每日构建过程

每日到达指定时间（一般是凌晨1:00），将触发每日构建过程。过程如下：

1. 设置版本号为字符串“D`BUILDER_NUMBER`”
2. 构建名为字符串“当前版本号-daily”。
3. 从版本仓库主线分支checkout完整的代码。然后判断组件子目录中哪些组件在上一日1:00 ~ 当日1:00之间发生了变化，变化的组件将会被编译。
4. 收集每一个需要构建的组件从上一日1:00 ~ 当日1:00之间的提交日志，并汇总作为构建时的changelog。
5. 将版本号写入特定的Java代码，该信息将在运行时写入运行日志。如果在上一步发现有多个组件需要编译，对于该次构建，这些组件的`BUILD_NUMBER`是相同的
6. 编译每一个需要构建的组件。不同组件间的编译可以是并发的。
7. 编译完成后，对每一个组件进行单元测试。不同组件间的测试可以是并发的。
8. 检查编译结果、单元测试结果和单元测试覆盖率。有任一项没有达到要求，则此次构建失败。
9. 对编译结果进一步执行组件测试、接口测试。
10. 检查上述测试结果。有任一项没有达到要求，则此次构建失败。
11. 如果构建成功，则将构建结果打包成docker image。其tag为“当前版本号-daily”。
12. 如果构建失败，将构建结果通知相关开发人员。

每日构建的目的主要是为测试人员提供测试用的基础docker包。每日构建的结果已经通过了基本的自动化测试，可以直接用于集成测试。

#### 候选标记过程

在测试完指定的构建版本并确认通过后，测试人员手工触发此过程。过程如下：

1. 测试人员选择或输入可以进入候选的构建版本。一般来说，这个版本是每日构建的版本，即“D`BUILD_NUMBER`-daily”；但也可以是提交编译的版本，即“C`BUILD_NUMBER`”。
2. 对docker registry上指定版本的image增加tag：[C|D]`BUILD_NUMBER`-rc。注意，这里的`BUILD_NUMBER`是每日构建过程或提交编译过程确定的，**与本次构建的构建号无关**。前面的C或D前缀根据每日构建版本还是提交编译版本来确定。
3. 如果选择的构建版本涉及多个组件，则多个组件一起被标记为rc。
4. 通知相关发布人员。

候选标记过程的目的是标记指定的版本测试通过，可以用于发布。

#### 发布标记过程

发布人员手工触发此过程。过程如下：

1. 发布人员选择或输入被标记为候选的构建版本。一般来说，这个版本是最新的候选版本。但也可以是之前的候选版本。
2. 对docker registry上指定候选版本的image增加tag：[C|D]`BUILD_NUMBER`-release。注意，这里的`BUILD_NUMBER`是每日构建过程或提交编译过程确定的，**与本次构建的构建号无关**。前面的C或D前缀根据每日构建版本还是提交编译版本来确定。
3. 如果选择的构建版本涉及多个组件，则多个组件一起被标记为release。
4. 通知相关实施人员。

发布标记过程的目的是标记指定版本可以发布。

### 发布过程

系统发布采用持续发布模式。代码审核人员将开发提交合并进入主线分支后，将触发提交编译过程。如果提交编译过程不通过，则开发人员必须在每日构建过程之前保证提交编译过程通过。确保每日构建过程执行时至少代码是可以正常编译和通过单元测试的。必要时可以退回修改重新提交。

测试人员在一轮测试完成后，进入持续集成工具查看每日构建的情况，根据实际需要选择一个每日构建结果进行新一轮的测试。如果每日构建结果无法测试，测试人员也可以酌情考虑使用某一个提交编译结果进行测试。

如果测试通过，测试人员可以将此版本标记为候选发布。

发布人员检查所有候选发布版本，从中选择一个作为发布版本。

实施人员通过部署工具将某一个发布版本发布至客户环境。（具体方法及工具待定）

如果发布版本出现bug或新需求，则纳入下一轮开发计划。

一次发布只解决一个或少数几个问题。发布的周期应该是快且频繁。

原则上发布应该是始终向前进。如果某次发布出现bug则进入下一轮发布阶段，在此阶段中修复bug。

但如果确实发现bug且无法在短时间内修复，可以考虑退回上一个发布，并抛弃当前发布版本。版本库恢复至上一次发布对应的提交，并做一次新的提交以作为新的起点流程流程。

## 框架开发流程

系统中一部分跨组件代码，将会被提取成公共库及框架。框架部分的开发流程与业务系统开发有所不同。

框架组件将以公共jar包的形式存在，通过maven仓库进行管理。业务系统使用gradle引用仓库中的包进行使用。

框架与业务系统使用不同的版本管理仓库，分开管理。

### 工具选型

#### 版本管理工具

与业务系统使用相同的工具。但需要单独创建仓库。

#### 持续集成工具

与业务系统使用相同的工具。

#### maven仓库

maven仓库使用JFrog的Artifactory库。需要注意的是，业务系统中使用的**所有**包均通过此仓库进行获取。其中公共库通过在Artifactory中制作远程仓库进行代理。公司内部开发的库及框架将上传至私有仓库。

### 开发过程

与业务系统采用类似的做法，在独立的仓库上进行开发。不再赘述。

需要注意的一点是，框架组件的用户是业务系统开发人员及框架组件开发人员。因此issue的主要提交者（包括bug和需求）是这些开发人员。

### 持续集成过程

与业务系统不同，框架组件是有明确的版本号概念的。框架组件的版本号将遵循[语义化版本](http://semver.org/lang/zh-CN)规范，每一个组件拥有自己独立的版本号。版本号在组件开发时定义在gradle文件中。

#### 提交编译过程

当版本仓库主线有新的提交时，将触发提交编译过程。过程如下：

1. 从版本仓库主线分支checkout完整的代码。然后判断组件子目录中哪些组件发生了变化，变化的组件将会被编译。
2. 从gradle文件中获取需要编译组件的版本号
3. 设置各组件最终版本号为字符串“组件版本号.`BUILD_NUMBER`”
4. 将最终版本号写回gradle文件。该版本号将作为编译结果文件（jar包）文件名的一部分。
5. 编译每一个需要构建的组件。不同组件间的编译可以是并发的。
6. 编译完成后，对每一个组件进行单元测试。不同组件间的测试可以是并发的。
7. 检查编译结果、单元测试结果和单元测试覆盖率。有任一项没有达到要求，则此次构建失败。
8. 如果编译失败，则通知相关开发人员。

提交编译过程主要是通过编译、单元测试及测试覆盖率来确保每次提交的正确性。另外，其构建结果也作为发布的备选结果使用。

### 发布过程

系统发布采用版本发布模式。

代码审核人员将开发提交合并进入主线分支后，将触发提交编译过程。如果提交编译过程不通过，则开发人员必须进行修改，保证提交编译过程正常通过。

由于框架的特殊性，其正确性由开发者自身来保证。这里没有单独的测试人员。

如果开发人员认为某一个提交编译结果正确，可以发布，则直接启动发布流程。

1. 发布时首先选择一个需要发布的jar（注意每一个jar是单独发布的，与是否在同一次构建无关）。
2. 去除jar包文件名中的`BUILD_NUMBER`。
3. 将其上传至maven仓库。
4. 记录此次发布。
5. 通知相关框架开发人员及业务系统开发人员。

### 框架版本使用

原则上来说，主版本号不变的情况下，业务系统开发人员应及时使用最新版的框架组件。主版本号变化的框架组件会有兼容性问题，需要酌情考虑是否选择使用。

但如果有特殊情况，也可以考虑使用非最新版的框架组件。但需要在issue中记录，说明做出该选择的原因，以便框架开发人员决策。

## 遗留问题

* 部署工具及方法待选型
* 当一个需求开发周期较长时，开发人员私有仓库或分支可能也需要持续集成工具配合以保证日常开发的质量。该过程尚未确定。